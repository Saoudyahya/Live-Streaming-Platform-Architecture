<!DOCTYPE html>
<html>
<head>
    <title>üöÄ Ultra Low Latency Stream Player</title>
    <script src="https://vjs.zencdn.net/8.0.4/video.min.js"></script>
    <link href="https://vjs.zencdn.net/8.0.4/video-js.css" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #0a0a0a;
            color: white;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #ff4444;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(45deg, #ff4444, #ff8800);
            border-radius: 8px;
            color: white;
        }
        .latency-display {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 18px;
        }
        .latency-box {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #555;
        }
        .latency-value {
            font-size: 24px;
            font-weight: bold;
            color: #00ff00;
        }
        .ultra-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
        }
        .ultra-buttons button {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-primary { background: #ff4444; color: white; }
        .btn-webrtc { background: #00aa00; color: white; }
        .btn-hls { background: #0066cc; color: white; }
        .btn-control { background: #666; color: white; }
        .ultra-buttons button:hover { transform: scale(1.05); opacity: 0.9; }
        .status {
            margin: 15px 0;
            padding: 12px;
            border-radius: 6px;
            font-weight: bold;
        }
        .status.live { background: #004400; border: 2px solid #00aa00; }
        .status.connecting { background: #444400; border: 2px solid #ffaa00; }
        .status.error { background: #440000; border: 2px solid #ff4444; }
        .debug {
            margin-top: 20px;
            padding: 15px;
            background: #111;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #333;
        }
        video {
            width: 100%;
            height: auto;
            border-radius: 8px;
            border: 2px solid #333;
        }
        .warning {
            background: #331a00;
            border: 1px solid #ff8800;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ ULTRA LOW LATENCY STREAMING</h1>
            <p>Target: &lt;1 second delay | Real-time streaming</p>
        </div>

        <div class="latency-display">
            <div class="latency-box">
                <div>Current Latency</div>
                <div class="latency-value" id="currentLatency">--</div>
                <div>seconds</div>
            </div>
            <div class="latency-box">
                <div>Buffer Level</div>
                <div class="latency-value" id="bufferLevel">--</div>
                <div>seconds</div>
            </div>
            <div class="latency-box">
                <div>Stream Type</div>
                <div class="latency-value" id="streamType">HLS</div>
                <div id="streamQuality">--</div>
            </div>
        </div>

        <video id="player" controls muted autoplay playsinline></video>

        <div id="status" class="status connecting">
            <span id="statusText">üîÑ Initializing ultra low latency player...</span>
        </div>

        <div class="ultra-buttons">
            <button onclick="startUltraHLS()" class="btn-hls">üî• Ultra HLS (1-2s)</button>
            <button onclick="startWebRTC()" class="btn-webrtc">‚ö° WebRTC (&lt;0.5s)</button>
            <button onclick="aggressiveSeek()" class="btn-control">‚è≠Ô∏è Jump to Live</button>
            <button onclick="minimizeBuffer()" class="btn-control">üóúÔ∏è Minimize Buffer</button>
            <button onclick="forceReconnect()" class="btn-primary">üîÑ Force Reconnect</button>
            <button onclick="clearDebug()" class="btn-control">üóëÔ∏è Clear Log</button>
        </div>

        <div class="warning">
            ‚ö†Ô∏è <strong>Ultra Low Latency Mode:</strong> This may cause occasional stuttering in exchange for minimal delay.
            For best results, ensure your RTMP encoder uses: GOP=15 frames, CBR, no B-frames.
        </div>

        <div id="debug" class="debug">
            <strong>üîç Debug Log:</strong><br>
        </div>
    </div>

    <script>
        let video = document.getElementById('player');
        let currentMode = 'hls';
        let latencyMonitor;
        let reconnectAttempts = 0;

        function log(message) {
            const debugEl = document.getElementById('debug');
            const time = new Date().toLocaleTimeString();
            debugEl.innerHTML += `[${time}] ${message}<br>`;
            debugEl.scrollTop = debugEl.scrollHeight;
            console.log(message);
        }

        function updateStatus(text, type) {
            document.getElementById('statusText').innerHTML = text;
            document.getElementById('status').className = `status ${type}`;
        }

        function updateLatencyDisplay(latency, buffer, type) {
            document.getElementById('currentLatency').textContent = latency.toFixed(2);
            document.getElementById('bufferLevel').textContent = buffer.toFixed(2);
            document.getElementById('streamType').textContent = type;

            // Color code latency
            const latencyEl = document.getElementById('currentLatency');
            if (latency < 1) latencyEl.style.color = '#00ff00';
            else if (latency < 3) latencyEl.style.color = '#ffff00';
            else latencyEl.style.color = '#ff4444';
        }

        function startUltraHLS() {
            log('üî• Starting Ultra Low Latency HLS...');
            currentMode = 'hls';

            // Destroy any existing Hls.js instance
            if (video.hls) {
                video.hls.destroy();
            }

            // Use cache-busting URL
            const hlsUrl = `http://localhost:8080/live/test.m3u8?ultra=${Date.now()}`;

            if (Hls.isSupported()) {
                const hls = new Hls({
                    // Ultra aggressive settings
                    liveSyncDurationCount: 1,           // Stay 1 segment behind live
                    liveMaxLatencyDurationCount: 2,     // Max 2 segments behind
                    maxBufferLength: 2,                 // 2 second max buffer
                    maxBufferSize: 5 * 1000 * 1000,    // 5MB max
                    maxBufferHole: 0.1,                 // Fill tiny gaps fast
                    lowLatencyMode: true,               // Enable LL-HLS features
                    backBufferLength: 0,                // No back buffer

                    // Aggressive seeking
                    enableWorker: false,                // Disable worker for speed
                    testBandwidth: false,               // Skip bandwidth tests
                    progressive: true,                  // Progressive download

                    // Fragment loading
                    fragLoadingTimeOut: 1000,           // 1s timeout
                    manifestLoadingTimeOut: 2000,       // 2s timeout
                    fragLoadingMaxRetry: 1,             // Quick retry
                    manifestLoadingMaxRetry: 1,
                });

                hls.loadSource(hlsUrl);
                hls.attachMedia(video);
                video.hls = hls;

                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    log('‚úÖ Ultra HLS manifest loaded');
                    video.play().catch(e => log('‚ö†Ô∏è Click play button'));
                    startLatencyMonitoring();
                });

                hls.on(Hls.Events.ERROR, (event, data) => {
                    log(`‚ùå HLS Error: ${data.type} - ${data.details}`);
                    if (data.fatal) {
                        setTimeout(() => {
                            log('üîÑ Auto-recovering from fatal error...');
                            startUltraHLS();
                        }, 1000);
                    }
                });

            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Safari native HLS
                video.src = hlsUrl;
                video.play().catch(e => log('‚ö†Ô∏è Click play button'));
                startLatencyMonitoring();
            }
        }

        function startWebRTC() {
            log('‚ö° Starting WebRTC Real-Time Stream...');
            currentMode = 'webrtc';

            // WebRTC URL (requires WebRTC-enabled SRS)
            const webrtcUrl = 'webrtc://localhost:8000/live/test';

            // This would require a WebRTC player library
            // For now, show how to implement it
            log('üìã WebRTC Setup Required:');
            log('1. Update SRS config with WebRTC support');
            log('2. Add WebRTC player library');
            log('3. Configure STUN/TURN servers');

            updateStatus('üîß WebRTC requires additional setup - using Ultra HLS', 'connecting');

            // Fallback to ultra HLS for now
            setTimeout(startUltraHLS, 2000);
        }

        function aggressiveSeek() {
            if (video.buffered.length > 0) {
                const bufferEnd = video.buffered.end(video.buffered.length - 1);
                video.currentTime = bufferEnd - 0.5; // Stay 0.5s from live edge
                log('‚è≠Ô∏è Jumped to live edge');
            }
        }

        function minimizeBuffer() {
            log('üóúÔ∏è Minimizing buffer for ultra low latency...');

            if (video.hls) {
                // Reconfigure HLS for even lower latency
                video.hls.config.maxBufferLength = 1;
                video.hls.config.liveSyncDurationCount = 0.5;
                log('‚úÖ Buffer minimized to 1 second');
            }

            aggressiveSeek();
        }

        function forceReconnect() {
            log('üîÑ Force reconnecting...');
            reconnectAttempts++;

            if (video.hls) {
                video.hls.destroy();
            }

            setTimeout(() => {
                if (currentMode === 'hls') {
                    startUltraHLS();
                } else {
                    startWebRTC();
                }
            }, 500);
        }

        function startLatencyMonitoring() {
            clearInterval(latencyMonitor);

            latencyMonitor = setInterval(() => {
                try {
                    const buffered = video.buffered;
                    const currentTime = video.currentTime;

                    if (buffered.length > 0) {
                        const bufferEnd = buffered.end(buffered.length - 1);
                        const bufferLevel = bufferEnd - currentTime;

                        // Estimate latency (this is approximate)
                        let estimatedLatency = bufferLevel + 0.5; // Base latency estimate

                        updateLatencyDisplay(estimatedLatency, bufferLevel, currentMode.toUpperCase());

                        // Auto-seek if buffer gets too large
                        if (bufferLevel > 3 && currentMode === 'hls') {
                            log('‚ö° Auto-seeking to reduce latency');
                            aggressiveSeek();
                        }

                        // Update status
                        if (video.paused) {
                            updateStatus('‚è∏Ô∏è Paused', 'connecting');
                        } else {
                            updateStatus(`üî¥ LIVE | ${estimatedLatency.toFixed(1)}s delay | ${bufferLevel.toFixed(1)}s buffer`, 'live');
                        }
                    }
                } catch (e) {
                    // Ignore monitoring errors
                }
            }, 250); // Update 4 times per second for responsive monitoring
        }

        function clearDebug() {
            document.getElementById('debug').innerHTML = '<strong>üîç Debug Log:</strong><br>';
        }

        // Auto-reconnect on errors
        video.addEventListener('error', () => {
            log(`‚ùå Video error: ${video.error ? video.error.message : 'Unknown'}`);
            setTimeout(forceReconnect, 2000);
        });

        // Handle play/pause events
        video.addEventListener('play', () => {
            log('‚ñ∂Ô∏è Playback started');
            startLatencyMonitoring();
        });

        video.addEventListener('pause', () => {
            log('‚è∏Ô∏è Playback paused');
        });

        // Load HLS.js library and start
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/hls.js@latest';
        script.onload = () => {
            log('üöÄ Ultra low latency player ready');
            startUltraHLS();
        };
        document.head.appendChild(script);

        // Auto-reconnect if stream stops
        setInterval(() => {
            if (!video.paused && video.readyState === 4) {
                const now = Date.now();
                if (video.lastTimeUpdate && now - video.lastTimeUpdate > 5000) {
                    log('üîÑ Stream appears stuck - reconnecting...');
                    forceReconnect();
                }
            }
            video.lastTimeUpdate = Date.now();
        }, 5000);
    </script>
</body>
</html>